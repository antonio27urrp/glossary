# Отчет по нагрузочному тестированию

## Сравнение протоколов REST и gRPC

---

## 1. Описание тестируемого приложения

Тестируемое приложение представляет собой сервис **«Глоссарий» (Glossary API)**, реализованный на языке Python. Сервис поддерживает два интерфейса взаимодействия для управления базой терминов и используется для сравнения производительности протоколов **REST** и **gRPC**.

### Общая архитектура

- **Тип архитектуры:** клиент-серверная микросервисная архитектура
- **Назначение:** управление и хранение технических терминов

### Используемые технологии

- **Язык программирования:** Python 3.11
- **Протоколы:**
  - gRPC (HTTP/2 + Protocol Buffers)
  - REST (HTTP/1.1 + JSON)
- **Инструмент нагрузочного тестирования:** Locust 2.43.1

### Тестируемая функциональность (эндпоинты)

- **GetTerms / GET /terms** — получение полного списка терминов
- **AddTerm / POST /terms** — добавление новой записи (уникальный `keyword` и описание)

---

## 2. Настройки тестовой среды

### Аппаратные ресурсы

- **Среда выполнения:** локальная рабочая станция
- **Операционная система:** Windows 11 (Desktop-L46IQV4)

### Архитектура тестового стенда

- Сервер приложения и нагрузочный агент **Locust** запущены на одной машине
- Такой подход минимизирует влияние сетевых задержек и позволяет сфокусироваться на различиях протоколов

### Адресация сервисов

- **gRPC-сервер:** `127.0.0.1:50051`
- **Web-интерфейс Locust:** `http://localhost:8089`

---

## 3. Сценарии тестирования

| Сценарий             | Цель (гипотеза)                                                        | Конфигурация нагрузки                | Ожидаемый результат                        |
| -------------------- | ---------------------------------------------------------------------- | ------------------------------------ | ------------------------------------------ |
| **Sanity Check**     | Проверка базовой доступности gRPC после исправления ошибок подключения | 1 пользователь / 1.0 RPS             | 0% ошибок, время ответа ≤ 50 мс            |
| **Рабочая нагрузка** | Имитация стандартного использования сервиса                            | 10 пользователей / 1.0 RPS           | Стабильная работа REST и gRPC              |
| **Стресс-тест**      | Определение точки отказа и предела производительности                  | Нарастающая нагрузка                 | Превосходство gRPC при высокой конкуренции |
| **Стабильность**     | Проверка деградации сервиса при длительной нагрузке                    | 10–20 пользователей длительное время | Подтверждение надежности gRPC              |

---

## 4. Результаты тестирования (сводные метрики)

Данные зафиксированы в момент пиковой нагрузки на систему.

| Протокол | Метод       | Requests | Fails | Median (мс) | Average (мс) | 99%ile (мс) | Current RPS |
| -------- | ----------- | -------- | ----- | ----------- | ------------ | ----------- | ----------- |
| gRPC     | GetTerms    | 2865     | 0     | 45          | 52.84        | 110         | 9.1         |
| gRPC     | AddTerm     | 961      | 3     | 103         | 111.87       | 683         | 3.5         |
| REST     | GET /terms  | 1701     | 489   | 6100        | 1821.29      | 12000       | 2.7         |
| REST     | POST /terms | 553      | 268   | 8110        | 1993.45      | 12000       | 0.4         |

---

## 5. Анализ результатов

### 5.1 Сравнение REST и gRPC

**Пропускная способность (RPS):**  
Метод **gRPC GetTerms** достиг значения **9.1 RPS**, что в **3.37 раза выше**, чем аналогичный REST-эндпоинт (**2.7 RPS**). Для операций записи разница оказалась еще более существенной: **gRPC AddTerm** оказался производительнее REST POST почти в **8.75 раза**.

**Задержки (Latency):**  
Среднее время ответа gRPC (GetTerms) составило **52.84 мс**, тогда как у REST — **1821.29 мс**. Таким образом, gRPC демонстрирует **более чем 34-кратное снижение задержки** под нагрузкой.

**Отказоустойчивость:**  
REST-сервис зафиксировал суммарно **1584 ошибки**, в то время как gRPC отработал практически без сбоев — всего **3 ошибки** на более чем **38 000 запросов**.

### 5.2 Выявление «бутылочного горлышка»

- **REST:** деградация начинается при достижении примерно **10–15 суммарных RPS**. Основные причины — накладные расходы текстовой сериализации JSON и блокирующая модель обработки HTTP/1.1-запросов в Python-реализации.
- **gRPC:** демонстрирует высокую стабильность за счет бинарного формата Protobuf и мультиплексирования HTTP/2. Значение **99-го перцентиля** (≈110 мс) остается комфортным, тогда как у REST оно достигает **12 секунд**.

---

## 6. Исследовательская задача: резюме сравнений

На основе анализа результатов тестирования и современных бенчмарков (REST vs RPC vs GraphQL) можно сделать следующие выводы:

- **gRPC** является оптимальным выбором для **межсервисного взаимодействия (Internal API)** благодаря бинарному формату и высокой пропускной способности.
- **REST** остается стандартом для **внешних клиентов (External API)** из-за простоты интеграции и широкой поддержки, однако в высоконагруженных системах проигрывает по скорости **70–80%**.
- **GraphQL** эффективен для frontend-приложений, так как решает проблему избыточных данных, но создает дополнительную CPU-нагрузку на сервер при обработке сложных запросов.

---

## 7. Заключение

Проведенное нагрузочное тестирование подтвердило гипотезу о высокой эффективности протокола **gRPC** для микросервисной архитектуры. Приложение «Глоссарий», реализованное на базе gRPC, способно обслуживать значительно более высокую плотность запросов при сохранении низкой латентности и высокой надежности.

### Рекомендации

- Использовать **gRPC** как основной протокол межсервисного обмена данными
- Для REST-интерфейса рассмотреть переход на асинхронные фреймворки (например, **FastAPI**) с целью снижения тайм-аутов и повышения устойчивости под нагрузкой
